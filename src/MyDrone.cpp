//
//  MyDrone.cpp
//
//   Sets up and renders the drone.
//
//   Comes supplied with the code for Sam Buss's "S".
//

// Use the static library (so glew32.dll is not needed):
#define GLEW_STATIC
#include <GL/glew.h> 
#include <GLFW/glfw3.h>

#include "LinearR3.h"		// Adjust path as needed.
#include "LinearR4.h"		// Adjust path as needed.
#include "MathMisc.h"       // Adjust path as needed

#include "ShaderBuild.h"

#include "MyGeometries.h"
#include "FinalProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"
#include "MyDrone.h"
#include "DrawScene.h"
#include "EulerMethod.h"

// These objects take care of generating and loading VAO's, VBO's and EBO's,
//    rendering spheres for the moon, earch and sun
GlGeomSphere mySphere;
GlGeomCylinder myCylinder;

//extern const int NumTextures;
extern unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
extern const char* TextureFiles[NumTextures];
extern GlGeomSphere texSphere;
extern GlGeomCylinder texCylinder;

// **********************
// This sets up geometries needed for the "Initial" (the 3-D alphabet letter)
//  It is called only once.
// **********************

void MySetupInitialGeometries() {
    // Initialize the sphere and cylinder, and give them "aPos" location.
    MyRemeshGeometries();
    mySphere.InitializeAttribLocations(aPos_loc);
    myCylinder.InitializeAttribLocations(aPos_loc);

    check_for_opengl_errors();
}
/*
void MyRemeshGeometries() {
    mySphere.Remesh(meshRes, meshRes);
    myCylinder.Remesh(meshRes, meshRes, meshRes);
}
*/

// *************************************
// Render the drone
// ************
void MyRenderDrone() {
    // Compute the animation factor.
    //    THIS IS SPECIFIC TO THE ANIMATION IN THE DEMO.
    //    FOR PROJECT 3 YOU MAY DO SOMETHING DIFFERENT, FOR INSTANCE, SIMILAR TO WHAT SolarProg.cpp DID.
    if (spinMode) {
		for (int i = 0; i < 4; i++) {
			currentPhase[i] += animateIncrement * spinVelocity[i];
			if (currentPhase[i] >= PI2) {
				currentPhase[i] -= PI2;
			}
		}
        if (singleStep) {
            spinMode = false;       // If in single step mode, turn off future animation
        }
    }

    // Render the drone as a group of ellipoids, and cylinder
    // Animate it as well.

	EulerMethod(centerOfGravityMatrix, currentVelocity, currentAngularVelocity, animateIncrement);

	LinearMapR4 centerOfGravityMatrix = viewMatrix;
	glVertexAttrib3f(aColor_loc, 0.8f, 0.8f, 0.8f);
	LinearMapR4 centerPosMatrix = centerOfGravityMatrix;
	centerPosMatrix.Mult_glRotate(PIfourths, 0.0, 1.0, 0.0);
	centerPosMatrix.Mult_glTranslate(0.0, -centerOfGravityHeight, 0.0);
	LinearMapR4 centerSphereMartix = centerPosMatrix;
	centerSphereMartix.Mult_glScale(centerSphereRadius, centerSphereRadius, centerSphereRadius);
	centerSphereMartix.DumpByColumns(matEntries);
	glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
	glBindTexture(GL_TEXTURE_2D, TextureNames[2]);     // Choose rough wood image texture
	glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
	texSphere.Render();                                 // Render the sphere
	glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
	for (int i = 0; i < 4; i++) {
		glVertexAttrib3f(aColor_loc, 0.0f, 0.8f, 1.0f);
		LinearMapR4 frameMatrix = centerPosMatrix;
		frameMatrix.Mult_glRotate((i - 0.5) * PIhalves, 0.0, 1.0, 0.0);
		frameMatrix.Mult_glRotate(PIhalves, 0.0, 0.0, 1.0);
		frameMatrix.Mult_glTranslate(0.0, centerSphereRadius, 0.0);
		LinearMapR4 connectPosMatrix = frameMatrix;
		connectPosMatrix.Mult_glTranslate(0.0, frameLength + connectSphereRadius, 0.0);
		frameMatrix.Mult_glScale(frameRadius, frameLength / 2.0, frameRadius);
		frameMatrix.Mult_glTranslate(0.0, 1.0, 0.0);
		frameMatrix.DumpByColumns(matEntries);
		glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
		glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose rough wood image texture
		glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
		texCylinder.RenderSide();                             // Render the sphere side
		glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose star image texture
		texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
		texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
		LinearMapR4 connectSphereMatrix = connectPosMatrix;
		connectSphereMatrix.Mult_glScale(connectSphereRadius, connectSphereRadius, connectSphereRadius);
		connectSphereMatrix.DumpByColumns(matEntries);
		glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
		glBindTexture(GL_TEXTURE_2D, TextureNames[2]);     // Choose rough wood image texture
		glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
		texSphere.Render();                                 // Render the sphere
		glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
		LinearMapR4 axleBottomMatrix = connectPosMatrix;
		axleBottomMatrix.Mult_glRotate(-PIhalves, 0.0, 0.0, 1.0);
		axleBottomMatrix.Mult_glTranslate(0.0, connectSphereRadius, 0.0);
		LinearMapR4 bladePosMatrix = axleBottomMatrix;
		bladePosMatrix.Mult_glTranslate(0.0, axleHeight, 0.0);
		axleBottomMatrix.Mult_glScale(axleRadius / 1.0, axleHeight / 2.0, axleRadius / 1.0);
		axleBottomMatrix.Mult_glTranslate(0.0, 1.0, 0.0);
		axleBottomMatrix.DumpByColumns(matEntries);
		glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
		glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose rough wood image texture
		glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
		texCylinder.RenderSide();                             // Render the sphere side
		glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose star image texture
		texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
		texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
		glVertexAttrib3f(aColor_loc, 1.0f-0.1*i, 0.4f+0.2*i, 1.0f-0.3*i);
		LinearMapR4 bladeMatrix = bladePosMatrix;
		bladeMatrix.Mult_glRotate(currentPhase[i], 0.0, 1.0, 0.0);
		bladeMatrix.Mult_glScale(bladeLength, bladeHeight, bladeWidth);
		bladeMatrix.DumpByColumns(matEntries);
		glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
		glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose rough wood image texture
		glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
		texSphere.Render();                                 // Render the sphere
		glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
	}
}
